الخطة التفصيلية (خطوة-ب-خطوة) — نسخة تيرمينال بلغة بايثون
نظرة عامة على المشروع (ملفّات ومخرجات)

مخرجات كل مرحلة ستكون قابلة للاختبار في التيرمينال. في نهاية كل مرحلة ستعرف بالضبط ماذا تعمل لتتحقق منها.

بنية المجلد المقترحة
math_push_py/
├─ main.py            # نقطة الدخول وحلقة اللعبة
├─ game.py            # منطق اللعبة (GameState, تحريك، دفع)
├─ level_loader.py    # تحميل المستويات من JSON
├─ evaluator.py       # استخراج التعبيرات وحسابها (scan & evaluate)
├─ renderer.py        # طباعة الخريطة بالترمينال
├─ state.py           # نماذج البيانات/كلاسات بسيطة (Cell, Gate, Player)
├─ levels/
│  ├─ level1.json
│  └─ ... (مستويات لاحقًا)
├─ tests/
│  ├─ test_movement.md # حالات اختبار يدوية
│  └─ ...
└─ README.md

المرحلة A — إعداد المشروع والملفات الأساسية (Outcome: project skeleton + تحميل مستوى بسيط)

مدة تقديرية: ~15–30 دقيقة

خطوة A1 — أنشئ المجلد والملفات الفارغة

أنشئ المجلد math_push_py والملفات الواردة في البنية أعلاه (محتواها يبدأ فارغًا أو مع تعليق يشرح الغرض).

Outcome: ملفات موجودة وجاهزة للتحرير.

خطوة A2 — صيغet تمثيل المستوى (JSON)

أنشئ ملف levels/level1.json بمحتوى يصف خريطة بسيطة تمثل فكرتك (هدف محمي بعدة قفل). مثلاً الحقول:

rows, cols

grid: مصفوفة 2D من رموز: '#' جدار، '.' فارغ، 'P' لاعب، أرقام '1'..'9'، +, -, G5 بوابة بقيمة 5، F خلية الهدف (Finish).

meta: اسم، وصف.

Outcome: مستوى أولي جاهز لتحميل.

خطوة A3 — كتابة level_loader.py

دالة load_level(path) -> LevelData:

تقرأ JSON وترجع كائن Python (dict) مع الحقول.

تتأكد من صحة الأبعاد (rows, cols) والتوافق مع طول grid.

Test: استدعِ load_level('levels/level1.json') من REPL واطبع الناتج.

Outcome: يمكنك فتح مستوى من ملف.

المرحلة B — نموذج البيانات وطبقة الحالة (Outcome: GameState مع grid وplayer)

مدة: ~30–60 دقيقة

خطوة B1 — صمم نموذج البيانات في state.py

صنف مبسّط Cell يمكن تمثيله كسلسلة/رمز.

صنف Gate يحتوي: pos=(r,c), value=int, is_open=bool.

صنف GameState يحتوي:

rows, cols

grid (قائمة قوائم من رموز/كائنات)

player_pos (r,c)

قائمة gates (كل قفل مع موضعه وقيمته)

finish_pos (pos of F)

initial_state (نسخة للـreset)

move_history (قائمة لحفظ حالات للـundo)

Outcome: لديك هيكل تمثيل لحالة اللعبة.

خطوة B2 — دالة لنسخ الحالة (deep copy)

اكتب دالة snapshot_state(state) -> deep_copy تحفظ الشبكة، موضع اللاعب، حالة البوابات.

Outcome: تستطيع حفظ واسترجاع الحالة للـUndo.

المرحلة C — طباعة الخريطة بالترمينال (Outcome: رؤية الخريطة نصياً)

مدة: ~20–40 دقيقة

خطوة C1 — renderer.py

دالة render(state) التي تطبع الـgrid بشكل واضح:

استخدم رموز مختصرة: # جدار، . فارغ، P لاعب، [1] رقم داخل مربع، +، -، (G5) بوابة مغلقة، خلية مفتوحة، [F] الهدف.

اطبع هدف كل قفل خارجيًا إن أردت (مثلاً قائمة gates في أسفل).

Test: استدعي render بعد تحميل level1.json -> يجب أن تشاهد الشكل بالترمينال.

Outcome: واجهة مرئية نصيًا.

المرحلة D — حركات اللاعب وقواعد الدفع (Chain Push) (Outcome: تحريك ودفع سلسلة كتل)

مدة: ~2–4 ساعات (يمكن تقسيمها)

خطوة D1 — دوال مساعدة للمواقع

next_pos(pos, dir) يحسب الموضع التالي.

in_bounds(pos) يتحقق ضمن الشبكة.

cell_at(pos), set_cell(pos, value).

خطوة D2 — منطق الدفع (game.py)

دالة attempt_move(state, direction):

احسب next = next_pos(player_pos, dir).

إذا next خارج الحدود أو جدار (#) أو بوابة مغلقة → لا تتحرك (راجع البوابات كحاجز).

إذا next فارغة → حرّك اللاعب.

إذا next تحتوي على قابل للدفع (رقم أو عامل):

احسب سلسلة من الخلايا المتتالية في هذا الاتجاه حتى تصل إما إلى خلية فارغة أو خلية غير قابلة للدفع.

إذا آخر خلية في السلسلة فارغة → انقل كل العناصر في السلسلة خطوة للأمام (ابدأ من نهاية السلسلة إلى بدايتها) ثم حرّك اللاعب.

إذا لا → تحرّك غير ممكن.

ملاحظة مهمة: البوابات المغلقة تُعامل كجدار؛ البوابات المفتوحة تعامل كخلايا فارغة.

Test: اكتب سيناريو في REPL: وضع مجموعة كتل أمام اللاعب، اطلب attempt_move('right') ويجب أن ترى الكتل تُزح للأمام بشكل سلسلة.

Outcome: يمكنك دفع أكثر من كتلة حسب المساحة المتاحة.

خطوة D3 — سجل الحركات للـUndo

قبل أي حركة ناجحة احفظ snapshot_state في move_history.

دالة undo() تسترجع الحالة الأخيرة.

دالة reset() تعيد initial_state.

Test: قم بحركة ثم undo ثم render لتتأكد من العودة.

المرحلة E — كشف التعبيرات وحسابها في أي مكان (scan & evaluate) (Outcome: كشف وتقييم تعابير أفقية وعمودية)

مدة: ~2–3 ساعات

خطوة E1 — قواعد اكتشاف التعبير

التعبير صالح إذا: تسلسل متتابع من الخلايا (أفقي أو عمودي) يحتوي على رموز بالتناوب: number (0-9) - operator (+ or -) - number - ...

طول التعبير ≥ 3 خانات (مثلاً 3 + 2).

خطوة E2 — دالة scan_line(start_pos, direction) في evaluator.py

تقرأ سلسلة الخلايا ابتداءً من start_pos مستمرة في direction حتى:

الوصول لخلية فارغة أو جدار أو بوابة مغلقة (توقف).

ترجع مصفوفة العناصر المقروءة.

خطوة E3 — دالة find_expressions(state):

تمر على كل خلية في الخريطة:

إذا الخلية رقمية ('1'..'9') أو علامة عملية، تحاول قراءة تعابير في الاتجاهين الأفقيين (يمين)، والأفقي العكسي (يسار) أو ببساطة افحص كل خلية رقم كبداية تقرأ إلى اليمين ولأسفل (لتفادي التكرار) — لكن يجب تجنّب تكرار التعبير نفسه مرتين.

استخدم scan_line لمقروئية التسلسل.

اختبر صلاحية النمط (number, operator, number,...).

خزن التعبير مع مواضعه (start, end, direction).

Test: صمّم شبكة صغيرة بعبارتين (أفقي وعمودي) واستعمل find_expressions لترى قائمة التعبيرات المكتشفة.

Outcome: وظيفة ترجع كل التعبيرات الحالية في الخريطة.

خطوة E4 — دالة evaluate_expression(expr_list):

باعتبارنا فقط + و -: تقييم من اليسار لليمين.

أعد نتيجة عددية.

Test: تمرير ["3", "+", "2", "-", "1"] → تعيد 4.

Outcome: يمكنك حساب قيمة أي تعبير صالح.

المرحلة F — ربط النتائج بفتح البوابات (Outcome: اختفاء القفل عند المطابقة)

مدة: ~1 ساعة

خطوة F1 — عندما يعثر find_expressions على تعبير صالح

احسب نتيجته.

قارن مع قيمة كل قفل في state.gates.

إذا result == gate.value:

افتح القفل: gate.is_open = True وإزالة الرمز Gx من الشبكة (استبداله بـ '.' أو خلية فارغة).

(خيار) احفظ سجل: أي تعبير فتح أي قفل (لـdebug أو عرض تاريخ).

Test: ضع بنية حيث 3+2 في الخريطة ووجود قفل G5 → بعد مسح التعبيرات يجب أن يختفي القفل.

Outcome: البوابات تُفتح تلقائيًا عندما يوجد تعبير مطابق في أي مكان.

المرحلة G — التحقق من طريق الفوز وإتمام المستوى (Outcome: فتح الطريق وcheckpoint الفوز)

مدة: ~30–60 دقيقة

خطوة G1 — التحقق من إمكانية الوصول إلى الـFinish

بعد فتح جميع البوابات المراد حلها (أو حسب متطلبات مستوى: قائمة gates يجب أن تكون كلها is_open == True):

اعتبر الممر إلى finish_pos مفتوحاً.

لاتحتاج لعمل خوارزمية Pathfinding معقدة طالما التصميم يبدأ من أنّ البوابات تغلق الطريق. لكن للتأكد يمكن عمل فحص بسيط: هل يوجد مسار من موقع اللاعب إلى finish_pos عبر خلايا غير جدران (BFS/DFS)؟ — هذا أفضل لأنه يتحقق إنما انفتحت كل المسارات المطلوبة.

Test: بعد فتح البوابات، استدعِ دالة is_reachable(player_pos, finish_pos) التي تقوم BFS على خلايا المارة ('.' أو بوابة مفتوحة).

Outcome: عندما يكون الـFinish reachable، إظهار رسالة "الآن يمكنك التوجه للهدف".

خطوة G2 — الفوز بالمرحلة

عندما اللاعب يتحرك ويصل إلى finish_pos:

اطبع رسالة نجاح.

(اختياري) تحميل مستوى تالي أو إعادة تشغيل.

Test: افتح البوابات ثم تحرّك اللاعب إلى الخلية F → يجب أن تتلقى رسالة نجاح.

Outcome: مستوى مكتمل.

المرحلة H — تجربة كاملة واختبارات (Outcome: مستوى يعمل بالكامل)

مدة: ~1–2 ساعات للاختبار والتصحيح

خطوة H1 — حالات اختبار يدوية

حالات: دفع سلسلة، اكتشاف تعابير أفقية/عمودية، فتح أكثر من قفل بنفس التعبير (لو مطلوب)، فتح أقفال متعددة، Undo/Reset.

سجّل الملاحظات وأصلح أي خطأ منطقي.

خطوة H2 — تحسينات طفيفة للـUX في التيرمينال

عرض تعليمات: WASD لتحريك، Z للـUndo، R للـReset، Q للخروج.

طباعة قائمة البوابات المتبقية وعدد الحركات.

المرحلة I — توسيعات مستقبلية (بعد الانتهاء)

دعم * و/ مع أولويات (تحتاج Shunting-yard).

دعم دمج أرقام لرقمين أو أكثر.

واجهة رسومية (Pygame).

محرر مستويات.

تفاصيل تنفيذية دقيقة لكل دالة مطلوبة (تكتبها لاحقًا بالكود)

أدرجت هنا أسماء الدوال والوظائف التي ستحتاجها لاحقاً لكي لا تضطر لتصميمها أثناء الكود:

level_loader.load_level(path) -> dict

state.GameState.from_level_dict(level_dict) -> GameState

state.snapshot(state) -> dict و state.restore(snapshot)

renderer.render(state)

game.next_pos(pos, dir)

game.attempt_move(state, dir) -> bool

game.push_chain(state, start_pos, dir) -> bool

game.save_move(state)

game.undo(state)

evaluator.scan_line(state, start_pos, dir) -> list

evaluator.find_expressions(state) -> list of {expr, start, end, dir}

evaluator.evaluate_expression(expr_list) -> int or None

game.check_and_open_gates(state) — يستدعي find_expressions ثم يفتح البوابات.

game.is_reachable(state, start, target) -> bool (BFS)

أمثلة مدخلات/مخرجات متوقعة لاختبار كل خطوة (لتسهيل الاختبار اليدوي)

بعد A: load_level('levels/level1.json') → يعيد dict بمفاتيح: rows, cols, grid, meta.

بعد C: render(state) → تطبع الشبكة، ترى P, أرقام، G5, F.

بعد D: في وضعية حيث أمام اللاعب سلسلة ['3','+','2','.'] عند attempt_move('right') ستصبح الأرقام متزحفة إلى اليمين.

بعد E: find_expressions(state) → يعيد [{"expr":["3","+","2"], "start":(r,c),"dir":"right"}, ...]

بعد F: بعد check_and_open_gates(state)، بوابة G5 تختفي من الشبكة (.) و gate.is_open == True.

بعد G: بعد فتح جميع gates وis_reachable(player_pos, finish_pos) → ترجع True. عندما player_pos == finish_pos → اطبع "Level Complete".

نقاط قرار ومفاهيم مهمة — قراراتك المطلوبة (أعلنها الآن إن كانت تروقك)

هل تريد أن يتم فتح القفل عند توافر أي تعبير يساوي رقمه (حتى لو كان التعبير مستخدمًا من قبل لفتح قفل آخر)؟ (أقترح: نعم، تعابير ليست "مستهلكة" ما لم نرغب بخلاف ذلك).

هل يمكن نفس التعبير أن يفتح أكثر من قفل في نفس الوقت إذا كانت القيم متطابقة؟ (أقترح: نعم—نفتح كل القفل المطابق).

هل تود تحديد حد أقصى لعدد الخطوات للـUndo؟ (مثلاً 100) أم لا حد؟ (أقترح: حد مرن مثل 1000 أو لا حد للمراحل الأولى).

هل تود طباعة اسم القفل والقيمة بجانبه دائمًا في render؟ (نعم سيفيد اللاعب).

إذا موافق على هذه القرارات نغطيها ضمن الخطة.

لماذا ننفّذ بهذه الخطوات بالضبط؟

نفصل العرض عن المنطق (Renderer عن GameState).

نكتب مكونات يمكن اختبارها منفصلة (loading, movement, scanning, evaluating).

نضمن أن الدفع المتسلسل (chain push) يعمل قبل أن نضيف التعقيد (scan & opening).

نتحقق من الوصول للـFinish عبر BFS لضمان أن الطريق فعلاً مقفل بالأبواب قبل فتحها.